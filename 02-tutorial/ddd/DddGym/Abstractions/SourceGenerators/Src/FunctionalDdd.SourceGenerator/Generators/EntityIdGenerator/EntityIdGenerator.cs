using FunctionalDdd.SourceGenerator.Abstractions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;
using static FunctionalDdd.SourceGenerator.Abstractions.Constants;

namespace FunctionalDdd.SourceGenerator.Generators.EntityIdGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class EntityIdGenerator() 
    : IncrementalGeneratorBase<EntityIdToGenerateEntry>(
        RegisterSourceProvider,
        Generate)
{
    private const string GenerateEntityIdAttributeMetadataName = "System.GenerateEntityIdAttribute";
    private const string GenerateEntityIdAttributeFileName = "GenerateEntityIdAttribute.g.cs";

    public const string GenerateEntityIdAttribute = Header + """

namespace System;

/// <summary>
/// Add to entities to indicate that entity id structure should be generated
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Generated by source generator.")]
public class GenerateEntityIdAttribute : global::System.Attribute;
""";

    private static IncrementalValuesProvider<EntityIdToGenerateEntry> RegisterSourceProvider(
        IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => 
            ctx.AddSource(
                GenerateEntityIdAttributeFileName,
                SourceText.From(GenerateEntityIdAttribute, Encoding.UTF8)));

        return context
            .SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: GenerateEntityIdAttributeMetadataName,
                predicate: Selectors.IsClass,
                transform: MapToEntityIdToGenerate)
            .Where(x => x != EntityIdToGenerateEntry.None);

        EntityIdToGenerateEntry MapToEntityIdToGenerate(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
        {
            if (context.TargetSymbol is not INamedTypeSymbol entitySymbol)
            {
                return EntityIdToGenerateEntry.None;
            }

            cancellationToken.ThrowIfCancellationRequested();

            string name = entitySymbol.Name + "Id";
            string @namespace = entitySymbol.ContainingNamespace.IsGlobalNamespace
                ? string.Empty
                : entitySymbol.ContainingNamespace.ToString();

            return new(name, @namespace);
        }
    }

    private static void Generate(SourceProductionContext context, ImmutableArray<EntityIdToGenerateEntry> entityIdToGenerateEntries)
    {
        foreach (var entityIdToGenerateEntry in entityIdToGenerateEntries)
        {
            StringBuilder sb = new();
            var result = entityIdToGenerateEntry.Generate(sb);
            context.AddSource(entityIdToGenerateEntry.Name + ".g.cs", SourceText.From(result, Encoding.UTF8));
        }
    }
}
