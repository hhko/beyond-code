using FunctionalDdd.SourceGenerator.Abstractions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;
using static FunctionalDdd.SourceGenerator.Abstractions.Constants;

namespace FunctionalDdd.SourceGenerator.Generators.EntityIdGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class EntityIdGenerator()
    : IncrementalGeneratorBase<EntityIdToGenerateEntry>(
        RegisterSourceProvider,
        Generate)
{
    private const string GenerateEntityIdAttributeMetadataName = "System.GenerateEntityIdAttribute";
    private const string GenerateEntityIdAttributeFileName = "GenerateEntityIdAttribute.g.cs";

    public const string GenerateEntityIdAttribute = Header + """

namespace System;

/// <summary>
/// Add to entities to indicate that entity id structure should be generated
/// </summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Generated by source generator.")]
public class GenerateEntityIdAttribute : global::System.Attribute;
""";

    private static IncrementalValuesProvider<EntityIdToGenerateEntry> RegisterSourceProvider(
        IncrementalGeneratorInitializationContext context)
    {
        // 
        // 1단계: GenerateEntityId 속성 생성
        //
        // Source Generator가 실행될 때 가장 먼저 [GenerateEntityId]라는 커스텀 속성(Attribute)을 생성하도록 합니다.
        // 이 코드는 실제 소스 코드에 해당 속성이 없어도 컴파일러가 이 속성을 인식하게 해 줍니다.
        //
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource(
                hintName: GenerateEntityIdAttributeFileName,                              // 생성할 파일 이름
                sourceText: SourceText.From(GenerateEntityIdAttribute, Encoding.UTF8)));  // 생성할 파일 소스

        //
        // 2단계: GenerateEntityId 속성이 있는 클래스 대상으로 소스 생성
        //
        // [GenerateEntityId] 속성이 있는 클래스를 EntityIdToGenerateEntry과 매핑합니다.
        // 
        return context
            .SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: GenerateEntityIdAttributeMetadataName,      // [GenerateEntityId] 이름이 붙은 구문 노드(Syntax)를 필터링합니다.
                predicate: Selectors.IsClass,                                           // [GenerateEntityId]가 클래스에 붙었는지 확인합니다
                transform: MapToEntityIdToGenerate)                                     // 추출된 클래스 정보를 EntityIdToGenerateEntry로 매핑합니다
            .Where(classDeclaration => classDeclaration != null)
            .Where(x => x != EntityIdToGenerateEntry.None);
    }

    private static EntityIdToGenerateEntry MapToEntityIdToGenerate(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        // 클래스가 없을 때
        if (context.TargetSymbol is not INamedTypeSymbol entitySymbol)
        {
            return EntityIdToGenerateEntry.None;
        }

        cancellationToken.ThrowIfCancellationRequested();

        // 클래스가 있을 때

        // 클래스 이름
        string name = entitySymbol.Name + "Id";
        // 클래스 네임스페이스
        string @namespace = entitySymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : entitySymbol.ContainingNamespace.ToString();

        return new EntityIdToGenerateEntry(name, @namespace);
    }

    // 매핑된 EntityIdToGenerateEntry로부터 소스 파일을 생성합니다.
    private static void Generate(SourceProductionContext context, ImmutableArray<EntityIdToGenerateEntry> entityIdToGenerateEntries)
    {
        foreach (var entityIdToGenerateEntry in entityIdToGenerateEntries)
        {
            StringBuilder sb = new();
            string source = entityIdToGenerateEntry.Generate(sb);   // 파일 소스 생성
            context.AddSource(
                entityIdToGenerateEntry.Name + ".g.cs",             // 생성할 파일 이름
                SourceText.From(source, Encoding.UTF8));            // 생성할 파일 소스
        }
    }
}
